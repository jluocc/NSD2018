day08回顾
两个容器类型
  set (可变集合)
  frozenset (不可变集合)
    存储不可变数据的容器
  无序/不能存在重复元素

运算:
  &交集  |并集  -补集  ^对称补集
  < >  == !=  <=  >=
  in / not in 

集合:
  {1,2,3}  / set()
  frozenset({1,2,3})  / frozenset()

方法:
  S.add()
  S.remove()
  S.discard()
  S.clear()
  S.pop()
  S.copy()
  S.update()

集合推导式:
   {x**2 for x in range(10)}
   {x for x in "AABCABC"}  # {'A','B','C'}

函数:
  创建函数的语法:
    def 语句:
      def 函数名(形参变量1, 形参变量2, ...):
          语句块

  函数的调用:
    函数名(实参1, 实参2, ...)
    表达式返回None

return 语句
  语法:
    return  # 相当于return None
    或
    return 表达式
  作用:
    用于终止函数的执行,返回一个对象的引用关系(默认返回None)



day09笔记
函数的参数:
  1.函数实际调用参数传递(把数据给函数)
  2.函数的形式参数(从调用者拿来(接收)数据)

函数的实际调用参数传递
  传递方式:
    1.位置传参
       1.1 序列传参
    2.关键字传参
       2.2 字典关键字传参

位置传参:
  实际参数(实参)的对应关系与形式参数(形参)的对应关系是按位置来依次对应的

  示意:
    def mymin(a, b, c):
        pass
    #         ^  ^  ^
    mymin(    1, 2, 3)
  说明:
    实参个数必须与形参个数相同
  示例见:
    position_give_args.py

序列传参:
  序列: 字符串,列表,元组
  序列传参是指在函数调用过程中,用*(星号)将序列拆解后按位置进行传递的传参方式
  示例见:
    sequence_give_args.py
  说明:
    序列传参时,序列拆解的位置将与形参一一对应
    序列的位置信息对应相应的参数位置
  
关键字传参
  关键字传参是指传参时,按着形参的名称给形参赋值
  实参和形参按名称进行匹配
  示例见:
    keywords_give_args.py
  说明:
    实参和形参可以不按位置进行匹配.

字典关键字传参
  是指实参为字典 将字典用 **(双星号) 拆解后进行关键字传参的传参方式

  示例见:
    dict_keywords_give_args.py

  说明:
    字典的键名和形参名必须一致
    字典的键名必须是字符串,且必须为标识符的命名规则
    字典的键名要在形参中存在

函数综合传参
  函数的传参方式,在能确定形参能唯一匹配到相应实参的情况下可以任意组合
  函数的位置传参要先于关键字传参 

  1. 函数的位置传参和序列传参可以混合使用,且可以顺序颠倒
    myfun1(100, *[200, 300])
    myfun1(*[100, 200], 300)
    myfun1(*[100], 200, *[300])
  2. 函数位置传参和关键字传参可以混合使用
    myfun1(100, c=300, b=200)
    myfun1(100, **{"c":300}, b=200)

-------以下讲的函数的定义及函数的形参----
函数的缺省参数
  语法:
    def 函数名(形参名1=默认实参1, 形参名2=默认实参2, ...):
        语句块
  示例见:
    default_args.py

  说明:
    1. 缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其右侧的所有参数都必须有缺省参数
    2. 缺省参数可以有0个,1个或多个,甚至全部都是缺省参数
  示例:
    def fn(a, b=10, c):  # 错的
        pass
    def fn(a=0, b=10, c=20):  # 对的
        pass
    
练习:
  写一个函数 myadd,此函数可以计算两个数,三个数及四个数的和.
    如:
      def myadd(...):
          ...
      print(myadd(10, 20))  # 30
      print(myadd(100, 200, 300))  # 600
      print(myadd(1, 2, 3, 4)) # 10


函数形参的定义方式:
  位置形参
  星号元组形参
  命名关键字形参
  双星号字典形参

位置形参:
  语法:
    def 函数名(形参名1, 形参名2, ...):
        语句块
  
星号元组形参
  语法:
    def 函数名(* 元组形参名):
        语句块
  作用:
    收集多余的位置传参
  说明:
    元组形参名一般命名为 'args'
  示例见:
    star_tuple_args.py

练习:
  写一个函数,mysum 可以传入任意个数字的实参,此函数调用将返回实参的和
  如:
    def mysum(*args):
        ...
    
    print(mysum())  # 0
    print(mysum(1, 2, 3))  # 6

练习:
  写一个函数min_max(...) 函数,
   此函数至少要传一个参数,并返回全部这些数数的最小值,最大值(形成元组,最小在前,最大值在后)
   调用此函数,得到最小值和最大值并打印出来
  如:
    def min_max(...):
        ...

    print(min_max(10, 20, 30))  # (10,30)
    x, y = min_max(8, 6, 4, 3, 9, 2, 1)
    print("最小值是:", x)
    print("最大值是:", y)
    print(min_max())  # 没有实参报错


命名关键字形参:
  语法:
    def 函数名(*, 命名关键字形参1,命名关键字形参2, ...):
        语句块
    # 或
    def 函数名(*args, 命名关键字形参1,命名关键字形参2, ...):
        语句块
  作用:
    强制所有的命名关键字形参都必须用关键字传参或字典关键字传参
  示例见:
    named_keyword_args.py

双星号字典形参
  语法:
    def 函数名(**字典形参名):
        语句块
  作用:
    收集多余的关键字传参

  说明:
    字典形参名一般命名为"kwargs"

  示例见:
    dict_keywords_args.py

函数的参数说明:
  位置形参,星号元组形参,命名关键字形参,双星号字典形参,缺省参数可以混合使用
  
函数参数自左至右的顺序为:
  位置形参
  星号元组形参
  命名关键字形参
  双星号字典形参

示例:
  def fx(a, b, *args, c, d, **kwargs):
      pass
  fx(1,2,3,4,5, c='C', d='D', e='E')

# 可以接收任意的位置传参和关键字传参的函数:
  def fn(*args, **kwargs):
        print('args=', args)
        print('kwargs=', kwargs)
  fn(1, 2, *"ABCD", *[11,22], 3, c=100,**{'a':200})


思考题:
  查看
    >>> help(print)
  猜想print()函数是形参列表是如何定义的?
    def myprint(*args, sep=' ', end='\n'):


  查看>>> range()函数猜想它的形参列表是如何定义的

练习:
  写一个myrange函数,参数可以传入1~3个,实际含义与range函数相同
  此函数返回符合range(...) 函数的列表
  如:
    L = myrange(4)
    print(L)  # [0, 1, 2, 3]
    L = myrange(4, 6)
    print(L)  # [4, 5]
    L = myrange(1, 10, 3)
    print(L)  # [1, 4, 7]
  (注: 可以调用range)


全局变量和局部变量
局部变量:
  定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
  局部变量只能在函数内部使用
  局部变量在函数调用时才能够被创建,在函数调用之后会自动销毁

全局变量:
  定义在函数外部,模块文件内部的变量称为全局变量
  全局变量,所有的函数都可以直接访问(但不能直接将其赋值)

示例见:
   global_local.py

说明:
  1. 在函数内部的赋值语句会创建局部变量,不会对全局变量造成影响
  2. 局部变量只能在其被声明的函数内部访问,而全局变量可以在整个模块范围内访问

globals() 和 locals() 函数
  globals() 返回当前全局作用域内变量的字典
  locals() 返回当前局部作用域内变量的字典

示例见:
  globals_locals.py

练习:
  素数/质数
    2, 3, 5, 7, 11, 13
  1. 写一个函数isprime(x) 判断x是否是素数.如果是素数返回True,否则返回False
    def isprime(x):
        ...
    print(isprime(4)) # False
    print(isprime(5)) # True

  2. 写一个函数prime_m2n(m, n)  返回从m开始,到n结束的范围内的素数(不包含n),返回这些素数的列表,并打印
    如:
      L = prime_m2n(5, 10)
      print(L)  # [5, 7]
  3. 写一个函数primes(n)  返回指定范围n以内的素数(不包含n)的全部素数的列表,并打印这些素数
      L = primes(10)
      print(L)  # [2, 3, 5, 7]
     1) 打印100以内的全部素数
     2) 打印200以内的全部素数的和
  4. 改写之前的学生信息管理程序:
     改为用两个函数实现
       1)写函数input_student() 来获取学生信息,当输入姓名为空时结束输入.形成字典组成的列表并返回
       2) 写函数print_student(L) 将上述函数得到的打印成为表格显示
    如:
      def input_student():
          ...
      def print_student(L):
          ... 
      L = input_student()  # 获取列表
      print(L)
      print_student(L)  # 打印表格










