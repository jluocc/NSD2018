函数变量
  def 函数变量名(形参列表):
      语句块
  
  def f1():
      pass
  f2 = f1  # f2 绑定 f1绑定的函数
  f2 = f1()  调用后返回None

函数可以作为参数传入另一个函数
  def fx(fn):
       ...
  fx(f1)  # 和 fx(f1())  不同
函数可以作为另一个函数的返回值
  def fy():
      return max
  def fz():
      def f2():
          pass
      return f2

函数嵌套定义
python 的四个作用域
  局部                      L
  外部嵌套函数作用域          E
  全局(函数所在模块的作用域)   G
  内建函数作用域              B

global 语句  (声明变量为全局变量)
nonlocal 语句 (声明变量为外部嵌套函数作用域内的变量)

lambda 表达式
  作用:
    创建匿名函数 
  语法:
    lambda 形参列表: 表达式

eval(字符串, 全局变量的字典,局部变量的字典)
  返回表达式执行后返回的对象
exec(字符串, 全局变量的字典,局部变量的字典)
  把字符串当成程序解释执行



day11 笔记
  函数式编程
    函数式编程是指用一系列函数解决问题
  
  函数是一等公民
  
  说明:
    用每一个函数完成细小的功能,一系列函数的任意组成可以解决大问题
    函数仅接受输入并产生输出,不包含任何可能影响输出的内部状态

函数的可重入性:
  当一个函数没有访问除局部变量以外的变量,则此函数为可重入函数
  示例:
    # 可重入函数
    def myadd1(x, y):
        return x + y

    # 不可重入函数
    s = 0
    def myadd2(x, y):
        global s
        s += x + y
        return s
    
高阶函数 High Order Function
  什么是高阶函数
    满足下列条件中一个的函数即为高阶函数
      函数接受一个或多个函数作为参数传入
      函数返回一个函数

python 内建的高阶函数
  map, filter, sorted

map 函数:
  map(func, *iterables)  返回可迭代对象,此可迭代对象用func对可迭代对象iterables中的每个元素作为参数计算后得到结果,再返回.当最短的一个可迭代对象不再提供数据时迭代结束
  示例见:
    map.py

练习:
  求: 1**2 + 2**2 + 3**2 + ... + 9**2的和

  求: 1**3 + 2**3 + 3**3 + ... + 9**3的和

  求: 1**9 + 2**8 + 3**7 + ... + 9**1的和

filter函数
  filter(func, iterable)  返回一个可迭代对象,此可迭代对象将对iterable获取到的数据用函数func进行筛选; func将对iterable中的每个元素进行求值，返回False则丢弃，返回True则保留此数据
  示例见:
    filter.py

练习:
  1. 把1～１００之间的全部素数放在列表primes中
  def isprime(x):
      ...
  ...



sorted 函数:
  作用：
  　将原可迭代对象的数据进行排序，生成排序后的列表
  格式:
    sorted(iterble, key=None, reverse=False)
  说明:
    iterable 是可迭代对象
    key 函数是用来提供比较值的函数，这个值将作用排序的依据
    reverse 标志用来设置是否降序排序
  示例见:
    sorted.py

练习:
names = ['Tom', 'Jerry', 'Spike', 'Tyke']
排序的依据是'moT'  'yrreJ', 'ekipS' 'ekyT'
结果是:
    ['Spike', 'Tyke', 'Tom', 'Jerry']
    (注:如果没有现成的函数可用,需要自己写函数)

递归函数 recursion
  函数直接或间接的调用自身

示例见:
  recursion_forever.py
示例:
  # 函数直接调用自己
  def f1():
      f1()  # 直接调用自己
  f1()

  # 函数间接调用自己
  def fa():
      fb()

  def fb():
      fa()  # 间接的调用自己
  fa()

说明:
  递归一定要控制递归的层数,当符合一定条件时要终止递归调用
  几乎所有的递归都能用while循环来代替
优缺点:
  优点是可以把问题简单化,让思路更为清晰,代码更简洁
  缺点是因系统环境影响大,当递归深度太大时,可能会得到不可预知的结果

递归函数调用分为两个阶段:
  1. 递推阶段
     从原问题出发,按递归公式递推从未知到已知,最终到达递归终止条件
  2. 回归阶段
     按递归终止条件求出结果,逆向逐步代入递归公式,回归原问题求解
示例见:
    recursion.py
    recursion_myfac.py

练习:
  用递归的方式求1 + 2 + 3 + ...  + n 的和
  def mysum(n):
      ...
  print(mysum(100))  # 5050

思考题:
  已知有五位朋友在一起
    第五位朋友说他比第四位朋友大2岁
    第四位朋友说他比第三位朋友大2岁
    第三位朋友说他比第二位朋友大2岁
    第二位朋友说他比第一位朋友大2岁
    第一位朋友说他10岁

  def getage(n): # 求第n个人的年龄
      ...


闭包 closure
  什么是闭包
    闭包是引用了此函数外部变量的函数

  闭包必须满足三个条件:
    1. 必须有内嵌函数
    2. 内嵌函数必须引用外部函数中的变量
    3. 外部函数返回值必须是内嵌函数
  示例见:
    closure.py

练习:
  1. 编写程序求 1 ~ 20的阶乘的和
    即:
      1! + 2! + 3! + ... + 20!
  2. 改写之前的学生信息管理系统
    要求添加四个功能:
      | 5)  按学生成绩高-低显示学生信息 |
      | 6)  按学生成绩低-高显示学生信息 |
      | 7)  按学生年龄高-低显示学生信息 |
      | 8)  按学生年龄低-高显示学生信息 |

  3. 已知有列表:
    L = [[3, 5, 8], 10, [[13, 14], 15, 18], 20]
    1) 写个函数print_list(lst)  打印出所有的数字,即:
      print_list(L)  # 打印3 5 8 10 13...
    2) 写一个函数sum_list(lst) 返回这个列表中所有数字的和
       print(sum_list(L))  # 106
  注:
    type(x) 可以返回一个变量的类型,如:
       >>> type(20) is int  # True
       >>> type([1, 2, 3]) is list # True


