>>> def fn():
...     pass
...
>>> fn.color='白色'
>>> fn.color
'白色'
>>> l=list()
>>> l.color='白色'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'list' object has no attribute 'color'
(可以看出，fn变量绑定的是一个函数，也是一个对象，但是l不能添加属性是
因为用__slots__限定了可输入属性的列表)

继承/派生
	继承可以直接使用父类的方法
	派生可以添加新的方法
单继承（只有一个父类）
覆盖条件：
	1.有继承
	2.子类中有同名的方法
	3.子类对象来调用同名的方法，出现覆盖现象

super（类，对象）（适用于有对象，类的实例对象调用函数）
super()  #等同于(当前类，self)  (适用于子类的函数内)

用于类的函数
issubclass(cls,cls_or_tuple)判断一个类是否继承自某个cls或
tuple中某些类中的一个类，如果是其中一个类的派生类，则返回是
True，否则返回False

封装 enclosure
封装是指隐藏类的实现细节，让使用者不用关心类的实现细节
封装的目的是让使用者通过尽可能少的方法属性来操作对象
通过私有属性和方法来封装

私有属性和方法
python类中以双下划线（'__'）开头，不以双下划线结尾的标识符为私有成员
私有成员只能使用类的方法来进行访问和修改

多态 polymorphic（运行的时候决定调用哪一个方法）
	字面意思：多种状态
	多态是指在继承和派生关系的类中，调用基类对象的方法，实际能调用子类的覆盖
	方法的现象较多态

状态：
	静态（编译时确定的状态）（优点：速度快，缺点：不灵活，C++）C++两种都有
	动态（运行时确定的状态）（反过来，java,C#,python，带有虚拟机的）
说明：
	多态调用的方法与对象相关，不与类型相关
	python全部对象都只有'动态'，没有'C++语言'编译时状态（静态）

面向对象的编程语言的特征：
	封装，继承，多态

多继承 multiple inheritance（python,c++）(java,C#不支持)
	多继承是指一个子类继承自两个或两个以上的父类（基类）
	语法：
		class 类名（基类名1，基类名2,....）:
			...
	说明：
		1.一个子类同时继承自多个父类，父类中的方法可以同时被继承下来
		2.如果两个父类中有同名的方法，而在子类中有没有覆盖此方法，调用结果难以确定

多继承的问题（缺陷）：
	标识符冲突的问题，要谨慎使用多继承（标识符一样的时候，有先后顺序，优先自己的，按照括号内的继承的类的顺序来）

多继承的MRO(Method Resolution Order)问题
类的 __mro__属性
作用：
	用来记录类的方法的查找顺序（可以看到所有的父类）

对象转字符串函数：
	str(obj)  通过给定的对象返回一个字符串（这个字符串通常是给人阅读的）
	repr(obj)返回一个符合python语法规则，且能代表此对象的表达式字符串，通常这个
	字符串一定是一个表达式(给机器识别的)
	通常：eval(repr(obj))==obj

函数重写：
	在自定义的类内添加相应的而方法，让自定义的类创建的实例能够向内建对象一样进行内建的函数操作

对象转字符串函数的重写方法：
	repr()函数的重写方法；
		def  __repr__(self):
		    ...
	str() 函数的重写方法：
		def  __str__(self):
		    ...
说明：
	1.str(obj)函数先查找obj.__str__()方法，调用此方法并返回结果
	2.如果obj.__str__()方法不存在，则调用obj.__repr__()方法，并返回结果
	3.如果obj.__repr__方法不存在，则调用object类的__repr__实例方法显示
	<__main__.xxxxobject at 0xxxxxxxxx>格式的字符串

>>> class A(object):
...     pass
...
>>> a=A()
>>> dir(a)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']

#####可以看到，a对象拥有父类的很多方法，类A如果没有定义方法，就会调用父类的

>>> l=list(range(10))
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print(l)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print(str(l))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print(l.__str__())
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
（都是相等的）

（重写有些时候是为了覆盖）
内建函数重写：
	__abs__       abs(obj)函数调用
	__len__       len(obj)函数调用
	__reversed__     reversed(obj)函数调用
	__round__       round(obj)函数调用

数值转换函数重写：
__complex__                complex(obj)函数调用
__int__                int(obj)函数调用
__float__                float(obj)函数调用
__bool__                bool(obj)函数调用

布尔测试函数重写
方法名：__bool__
作用：
	用于bool(obj)函数取值
	用于if语句的真值表达式
	用于while语句的真值表达式
说明：
	1.类内有__bool__（self）方法，调用obj.__bool__方法取值
	2.当不存在__bool__（self）方法，将用obj.__len__()方法的返回值求布尔值
	3.如果不存在__len__(self) 方法,则直接返回True

（能重写的函数有个特征,函数名（obj）等同于（obj）.__函数名__()）
（max，sum不能重写，传进来的不是对象）

迭代器（高级）
什么是迭代器：
	可以用next(it)函数取值的对象，就是迭代器
迭代器协议
	迭代器协议是指对象能够使用next函数获取下一个数据，在没有下一个
	数据是触发一个StopIteration异常来终止迭代的约定
迭代器协议的实现方法：
	def __next__(self):
	    ...

什么是可迭代对象
是指能用iter(obj)函数返回迭代器的对象（实例）
可迭代对象的实现方法：
	def __iter__(self):
		...
		return 迭代器
（如，列表是迭代对象，有iter方法，it是迭代器，有next方法）