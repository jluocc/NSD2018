dir()不加任何参数则默认查看全部全局变量
（全局变量或多一个变量，且所有人都可以修改）

类变量：
	类变量是类的属性，此属性属于类，不属于类的实例

	作用：通常用来存储该类创建的对象的共有属性
	说明：
		类变量可以通过该类直接访问
		类变量可以通过类的实例直接访问(取值)
		类变量可以通过此类的对象的__class__属性间接访问
###########################################################
class Car:
    total_count=0  ####创建类变量，不是全局，也不是局部
print(Car.total_count)
Car.total_count+=100
print(Car.total_count)

c1=Car()
print(c1.total_count)
c1.total_count+=100   ######创建实例变量，并赋值
print(c1.total_count)
print(Car.total_count)

c1.__class__.total_count=888   ####改变的是类变量
print(c1.total_count)　###优先找实例变量
print(Car.total_count)

0
100
100
200
100
200
888
############################################
class Car:
    total_count=0  ####创建类变量，不是全局，也不是局部
    def __init__(self,info):
        self.info=info
        print('汽车',info,'被创建')
        self.__class__.total_count+=1
    def __del__(self):
        print('汽车%s对象被销毁' % self.info)
        # self.__class__.total_count-=1     这个更好，易于维护
        Car.total_count-=1

c1=Car('BYD E6')  ###这里的参数会传给初始化函数的info参数
c2=Car('吉利　E7')
del c2
print('当前有%d个汽车对象' % Car.total_count)

汽车 BYD E6 被创建
汽车 吉利　E7 被创建
汽车吉利　E7对象被销毁
当前有1个汽车对象
汽车BYD E6对象被销毁
#############################################
class Car:
    total_count=0  ####创建类变量，不是全局，也不是局部
    def __init__(self,info):
        self.info=info
        print('汽车',info,'被创建')
        self.__class__.total_count+=1
c1=Car('BYD E6')  ###这里的参数会传给初始化函数的info参数
c2=Car('吉利　E7')
print('当前有%d个汽车对象' % Car.total_count)

汽车 BYD E6 被创建
汽车 吉利　E7 被创建
当前有2个汽车对象
###############################看看打印区别

类的文档字符串：（03.txt）
	类内第一个没有赋值给变量的字符串为文档字符串，类的文档
	字符串可以用类的__doc__属性访问（它是类对象）

####类也是对象

类的__slots__列表
作用：
	1.限定一个类创建的实例只能有固定的实例变量（实例属性）
	2.不允许对象添加列表以外的实例属性
	3.防止用户因错写属性名称而发生错误
	4.提高程序的执行速度
说明：
	1.__slots__属性是一个列表，列表的值是字符串
	2.含有__slots__属性的类所创建的对象没有__dict__属性
	，即此实例不用字典来存储实例属性

类方法(@classmethon)
	类方法是用于描述类的行为的方法，类方法属于类，不属于该类创建的实例对象

说明：
	1.类方法需要使用@classmethon装饰器定义
	2.类方法至少有一个形参，第一个形参用于绑定类，约定为'cls'
	3.类和该类的实例都可以调用此方法
	4.类方法不能访问此类

（实例方法实例来调，类方法用类来调，绑定的是类，self绑定实例,cls绑定类
他们的根本区别是是否用装饰器，而不是参数名称）

静态方法：（方法!=函数，方法多用于类）
	静态方法是定义在类的内部的函数，此函数的作用域是类的内部
说明：
	1.静态方法需要使用@staticmethod装饰器定义
	2.静态方法与普通函数定义相同，不需要传入
	'self'和'cls'参数
	3.静态方法只能凭借该类或类的实例调用
	4.静态方法不能访问类变量和实例变量

(说明：类和实例都要用到就用实例方法，只用到类就用类方法，类和实例都不用到就用静态方法)
（类方法主要是替代一些函数，少很多的全局变量）

继承(inhertance)和派生(derived)  （对象不同，父子）
	继承是从已有的类中派生出新的类，新类具有原类的属性和行为，并能扩展新的能力
	派生类就是从一个已有类中衍生出新类，在新的类上可以添加新的属性和行为

作用：
	1.用继承派生机制，可以将一些共有功能加在基类中，实现代码的共享
	2.在不改变基类代码的基础上改变原有类的功能

名词：
	基类（base class），超类(super class)，父类(father class)
	派生类（derived class），子类(child class)

单继承：
	语法：
		class 类名（基类名）:
			语句块
说明：
	单继承是指派生类由一个基类衍生出来

（当出现大量代码重复，用函数（面向对象），继承派生（面向对象）
代码赋值会导致代码很多，且要修改的是时候该的量很大）
（继承可以传递继承）

继承说明：
	python3任何类都直接或间接的继承自object类，object类是一切类的超类
	（类后不加括号参数，就默认继承自object类，可写可不写，python3中是这样，python2不是，必须写）

类的__base__属性
	作用：
		用来绑定此类的基类
>>> class Human:
...     pass
...
>>> class Student(Human):
...     pass
...
>>> class Teacher(Student):
...     pass
...
>>> Teacher.__base__
<class '__main__.Student'>
>>> Student.__base__
<class '__main__.Human'>
>>> Human.__base__
<class 'object'>
>>>
>>> object.__base__ is None
True

#########################################

python3中的内建内继承关系见:
  >>> help(__builtins__)
（bool 是 int的子类）
>>> True+True
2
>>> 3 is True ###########只有0,1
False

覆盖override
	什么是覆盖：（先找自身的，没有就找父类的，可看出优先级）
		覆盖是指在有继承关系的类中，子类中实现了与基类同名的方法，在子类的实例
		调用该方法时，实际调用的子类中覆盖版本，这种现象叫做覆盖
class A:
    def work(self):
        print('A.work被调用')
class B(A):
    def work(self):
        print('B.work被调用')
b=B()
b.work()  ######不需参数
A.work(b)  #########需要参数

B.work被调用
A.work被调用
###################################################################
子类对象显示调用基类方法的方式：
	基类名.方法名(实例，实际调用传参...)

super函数：
	super(cls,obj) 返回绑定超类的实例（要求obj必须是cls类型的实例）
	super()返回绑定超类的实例，等同于super
	（__class__，实例方法的第一个参数）必须在方法内调用
	（子类对象可以当成父类对象来用）

作用：
	借助super()返回实例间接调用父类的覆盖方法

显示调用基类的初始化方法：
	当子类中实现了__init__方法，基类的初始化方法就不会被调用
	此时需要显示调用基类的初始化方法

