列表
	向列表内添加数据
	l[0:0]=[x,a,f]
	修改数据将需要的地方修改值就行
	删除将需要删除的地方赋值为空就行
	del 语句
	用于删除列表中的元素
	示例；
		del l[2]    删除单个元素
		del  l[2:4]    删除切片
注意:列表执行删除循环的时候下标很容易变，变了之后索引的值就不一样了
l=[1,2,3,4,5,6,7,8,9,10]
for i in range(10):
    print(l[i])
    del(l[i])

tarena@tedu:~/test$ python test05.py
1
3
5
7
9
Traceback (most recent call last):
  File "test05.py", line 3, in <module>
    print(l[i])
IndexError: list index out of range




>>> l
[1, 2, 3, 4]
>>> l[3:]=[5,6]
>>> l
[1, 2, 3, 5, 6]
>>> l[3:3]=[4]
>>> l
[1, 2, 3, 4, 5, 6]

列表反转：
l[::]=L[::-1]    注意和l=l[::-1]的区别，这个id会变

python3中常用语序列的函数
len(x)  返回序列长度
max(x)  返回序列中的最大值元素（可与字符串相比）（后来又不行了）
l=[1,2,'a','A',5]
print(max(l))

tarena@tedu:~/test$ python test05.py
a

min(x)  返回序列中的最小值元素
sum(x)  返回序列中所有元素的和（元素必须是数值类型）
	因为sum默认一开始为0，只能与整型相加，不能和字符串，但让也有方法
any(x)  真值测试，如果序列中其中一个为真则为真
all(x)  真值测试，如果列表中所有值为真返回真

插入新的元素可以用、
l+=[n]
l[len(l):len(l)]=[n]

python3中常用的列表方法
>>> l=[1,3,5,7]
>>> l2=l
>>> l2[1]=1
>>> print(l)
[1, 1, 5, 7]
这是两个变量共同绑定一个值，共用
所以一个值变化两个列表都变
用copy解决

注意
>>> l.append([34,57,7])
>>> l+=[2,35,7]
>>> l
[1, 1, 5, 7, [34, 57, 7], 2, 35, 7]
>>> l.extend([4,6,8])
>>> l
[1, 1, 5, 7, [34, 57, 7], 2, 35, 7, 4, 6, 8]

L.sort(reverse=False)	
将列表中的元素进行排序，默认顺序按值的小到大的顺序排列
从大到小，改为True

L.reverse()	列表的反转，用来改变原列表的先后顺序（ip地址不会变）
也可以用l[::]=l[::-1]

L.pop([index])	删除索引对应的元素，如果不加索引，
默认删除最后元素，同时返回删除元素的引用关系(实际是拿)
[1, 1, 5, 7, [34, 57, 7], 2, 35, 7, 4, 6, 8]
>>> v=l.pop(2)
>>> print(v)
5


浅拷贝和深拷贝（切片要有[],赋值可以不用）
	浅拷贝 shallow copy           （用'='，没有拷贝,不导入copy，只拷贝一层）
	浅拷贝是指在对象复制过程中，指复制一层变量，不会
	复制深层变量绑定的对象的复制过程
>>> l=[3.1,3.2]
>>> l1=[1,2,l]
>>> l2=l1.copy()
>>> l[0]=3.14
[1, 2, [3.14, 3.2]]
>>> l2
[1, 2, [3.14, 3.2]]
>>> l
[3.14, 3.2]
>>> l1
[1, 2, [3.14, 3.2]]

深拷贝 deep copy
import copy
l2=copy.deepcopy(l1)
深拷贝需要大量的时间和空间内存


列表是可变的，字符串是不可变的
可变的就是改变一个绑定的对象，相关的绑定对象也会跟着改变

列表与字符串比较：
	都是序列/元素之间有先后顺序关系
	字符串是不可变的序列，列表是可变的序列
	字符串中每个元素只能存储字符（编码），而列表可以存储任意类型的颜色
	列表和字符串都是可迭代对象

	（字符串的拼接后的结果是一个新的）

字符串文本解析方法split 和join
S.split(sep=None)将字符串，使用sep作用分隔符分隔，s字符串，返回
分割后的字符串列表，当不给定参数是，用空白字符作用分隔符分隔
（后面不能是列表，只能是字符串，将空格替换成其他字符，字符不能什么都不填，
得到的结果是列表）

S.join(iterable)用可迭代对象中的字符串口中，返回一个中间用s进行分隔的
字符串
（如果可迭代对象是列表，则是拼接，如果是字符串，则可以理解为拆分，得到的结果是
字符串）

示例：
s='Beijing is capital'
L=s.split(' ')  

>>> s='Beijing is capital'
>>> s.split(' ')
['Beijing', 'is', 'capital']

>>> s='aaa v  \n  ccc'
>>> s.split('')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: empty separator
>>> s.split(' ')
['aaa', 'v', '', '\n', '', 'ccc']
>>> s.split()
['aaa', 'v', 'ccc']

>>> l=['sdf','etb','yuo','566']
>>> '#'.join(l)
'sdf#etb#yuo#566'
>>> ''.join(l)
'sdfetbyuo566'

>>> a='hello'
>>> ' '.join(a)
'h e l l o'
>>> '-'.join(a)
'h-e-l-l-o'

列表推到式list comprehension
列表推导式式用可迭代对象创建列表的表达式
作用：
	用简易方法生成列表
语法；
[表达式 for 变量 in 可迭代对象]
或
[表达式 for 变量 in 可迭代对象 if  真值表达式]
示例；
	#   以下生成一个数值为1-9的平方的列表
	l=[x**2 for x in range(1,10)]
	print([x**2 for x in range(1,100) if x%2==1])
	print([x**2 for x in range(1,100,2)])